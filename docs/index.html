<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">Publishing Linked Data Event Streams</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="citation_title" content="Publishing Linked Data Event Streams">
  <meta name="citation_author" content="Andreas De Witte" />
  <meta name="citation_author" content="Pieter De Clercq" />
  <meta name="citation_author" content="Robin Devos" />
  <meta name="citation_author" content="Sieben Veldeman" />
  <meta name="citation_author" content="Harm Delva" />
  <meta name="citation_author" content="Dwight Van Lancker" />
  <meta name="citation_author" content="Pieter Colpaert" />
  
  <meta name="citation_publication_date" content="2020/12/20" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="publishing-linked-data-event-streams">Publishing Linked Data Event Streams</h1>

  <ul id="authors">
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://github.com/dreeki" typeof="foaf:Person schema:Person" resource="Ghent University">Andreas De Witte</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://github.com/thepieterdc" typeof="foaf:Person schema:Person" resource="Ghent University">Pieter De Clercq</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://github.com/RobinDevos" typeof="foaf:Person schema:Person" resource="Ghent University">Robin Devos</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://github.com/sveldema" typeof="foaf:Person schema:Person" resource="Ghent University">Sieben Veldeman</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://hdelva.be" typeof="foaf:Person schema:Person" resource="IDLab - Ghent University - imec">Harm Delva</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://github.com/ddvlanck" typeof="foaf:Person schema:Person" resource="IDLab - Ghent University - imec">Dwight Van Lancker</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://www.pietercolpaert.be" typeof="foaf:Person schema:Person" resource="https://pietercolpaert.be/#me">Pieter Colpaert</a></li>
  </ul>

  <ul id="affiliations">
    <li id="ugent">Faculty of Engineering and Architecture,
          Ghent University</li>
    <li id="idlab">IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec</li>
  </ul>

  <section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <p>The Web in its current state cannot easily be interpreted by machines, as the majority of data resources and APIs are documented solely in natural language. This problem can be solved by augmenting resources on the web with semantic metadata; forming the so-called Semantic Web. An open problem is finding a generic approach to process such data in a streaming fashion and propagating updates to data reusers. An idiomatic solution to this problem should build on top of established Semantic Web standards, such as HTTP and RDF. This paper focuses on getting updates to the end-users as soon as possible, for which the applicability of existing technologies has been investigated. Our findings show that this subject can be further divided into four subtasks: (i) formatting, (ii) versioning, (iii) delivery, and (iv) caching. Although every subtask can be solved using existing technologies, none are sufficient to solve the larger problem. We conclude that the solution must lie in the combination of these existing technologies, and that future research should focus on end-to-end solutions – and not only the smaller subtasks.</p>
    </div>
</section>

</header>

<main>
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Introduction</h2>

      <p>On top of the standard Web, which is made for humans, resides the <em>Semantic Web</em>. This extension of the Web is used by machines to interpret documents on the web and thus extract information. The Semantic Web is not just about putting data on the Web though, linking to other resources so that more data can be discovered is just as important. Tim Berners-Lee outlined the four principles of <em>Linked Data</em> <span class="references">[<a href="#ref-1">1</a>]</span>: (i) use URIs as names for things, (ii) use HTTP URIs so that people can look up those names, (iii) when someone looks up a URI, provide useful information using standards such as Resource Description Framework <span class="references">[<a href="#ref-2">2</a>]</span> (RDF), and (iv) include links to other URIs so that they can discover more things.</p>

      <p>This paper focuses on a specific problem that can be solved using Linked Data. This problem involves finding a generic approach for both publishing and updating datasets. Publicly available datasets<sup id="fnref:exmp" role="doc-noteref"><a href="#fn:exmp" class="footnote">1</a></sup> such as public transport schedules and parking spot availability are inherently real-time. Consequently, receiving an update even 30 seconds too late could already render the data obsolete. However, not every dataset incurs the same volatility. An example is the registry of postal addresses, which may change due to the merging of municipalities, or the currently relevant COVID-19 datasets<sup id="fnref:covid" role="doc-noteref"><a href="#fn:covid" class="footnote">2</a></sup>, which are updated once per day. Both kinds of datasets have changes that need to become available to possible client applications – as soon as possible, as the change indicates an invalidation of the old dataset.</p>

      <p>Deciding the best strategy is influenced by two aspects. The first one is scalability: some technologies are inherently more scalable than others, and these must be compared and evaluated alongside mechanisms such as caching. The second aspect is the volatility of the dataset: data that is changed frequently can benefit from using a streaming-based approach. These aspects have led to an increase in research interest involving Linked Data streaming <span class="references">[<a href="#ref-3">3</a>]</span>.</p>

      <p>In this paper, we present the state of the art regarding this subject. First, the formatting of the data is discussed, together with an overview of some of the RDF serialization formats. The following section considers the versioning of data, namely why this is important and how to execute it. The next section discusses the delivery of data and how publishers can get their data to end-users, together with the criteria to choose an approach. Afterward, caching of data is discussed, different caching strategies for linked data are considered and compared. Finally, the last section applies all of the aforementioned subjects to the use-case of data streaming.</p>
    </div>
</section>

  <section id="semantic-web" inlist="" rel="schema:hasPart" resource="#semantic-web">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Semantic Web</h2>
      <p>The term <em>&#8216;’Semantic Web’‘</em> was first introduced by Tim Berners-Lee in 2001 <span class="references">[<a href="#ref-4">4</a>]</span>. The Semantic Web was established to solve the main problem of the Web, being that the Web is readable for humans, but not for machines. With the Semantic Web, machines should be able to interpret the Web. These machines are called intelligent agents and they will be able to fulfill complex tasks autonomously.</p>

      <p>To achieve this goal, a preliminary step is that publishers of data must be able to assign a meaning to the elements of the dataset. More specifically, machines must be able to understand this meaning without human intervention. Since datasets can have a variety of natures and topics, there is a need for so-called <em>ontologies</em>, which can be compared to vocabularies for humans. However, vocabularies define terms and ontologies define how these terms are related, mostly for reasoning. Finally, the Semantic Web must be <em>decentralized</em>, which means that data should not be contained on a single or a few servers <span class="references">[<a href="#ref-4">4</a>]</span>.</p>

      <h3 id="semantic-web-stack">Semantic Web Stack</h3>

      <p>The architecture of the Semantic Web is based on a hierarchy of technologies. This hierarchy is composed as a bottom-up approach, in which every layer uses the layer(s) directly beneath to achieve its goal. This strategy is visualized in <a href="#semanticstack">Fig. 1</a>. Since the subject of this paper is the publishing of data, only the layers that are relevant to this extent are considered. In the figure, this corresponds to the bottom five layers (indicated in bold).</p>

      <figure id="semanticstack">
<img src="images/semantic-web-stack.svg" alt="[Semantic Web Stack]" />
<figcaption>
          <p><span class="label">Fig. 1:</span> Semantic Web Stack (based on <span class="references">[<a href="#ref-5">5</a>, <a href="#ref-6">6</a>]</span>). This image reflects the original Semantic Web Stack from 2001. As a result, some of the technologies are outdated or deprecated (e.g. URI and XML). The relevant technologies for this paper are indicated in bold.</p>
        </figcaption>
</figure>

      <h4 id="unicode">Unicode</h4>

      <p>Unicode<sup id="fnref:unicodespec" role="doc-noteref"><a href="#fn:unicodespec" class="footnote">3</a></sup> is a system that is used to guarantee a consistent encoding, representation, and handling of text. Similar to ASCII, Unicode was established to aid developers in the creation of applications. However, the advantage of Unicode is that it solves the problems that exist in previous encoding schemes, such as the inability to encode all characters. This problem in particular is tackled by assigning an identifier to each character on every platform, for every program, and in every language.</p>

      <h4 id="uniform-resource-identifier-uri">Uniform Resource Identifier (URI)</h4>

      <p>A URI offers a uniform way to identify an object. This identifier is often confused with a <em>Uniform Resource Locator (URL)</em>, which <em>locates</em> an object, rather than <em>identifying</em> it. Consequently, every URL is an example of a URI, but not vice versa<sup id="fnref:urispec" role="doc-noteref"><a href="#fn:urispec" class="footnote">4</a></sup>.</p>

      <p>Together with Unicode, which was a W3C recommendation for the Web, URI resides at the foundations of the Semantic Web Stack. This combination enables the identification of resources on the Web uniformly.</p>

      <h4 id="extensible-markup-language-xml">Extensible Markup Language (XML)</h4>

      <p>XML is used to describe data. The most important traits of XML are that it is a flexible, simple and extensible format to store data. XML defines elements using so-called &#8220;tags’’, with every element having both a start-tag and an end-tag. Furthermore, XML supports nested elements, enabling the creation of hierarchies. Since it was a W3C recommendation, XML is at the lower part of the Semantic Web Stack.</p>

      <h4 id="resource-description-framework-rdf-model-syntax-and-schema">Resource Description Framework (RDF) Model, Syntax and Schema</h4>

      <p>The final element of the Semantic Web Stack is RDF, which is used to add meta-information to a dataset in a describing way. Due to the importance of RDF for the rest of this paper, it is explained in detail in <a href="#formatting-RDF">RDF</a>.</p>
    </div>
</section>

  <section id="formatting" inlist="" rel="schema:hasPart" resource="#formatting">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Data formatting</h2>

      <p>In this section, different ways to format and serialize RDF data are discussed. RDF data can be formatted into multiple formats, such as RDF/XML <span class="references">[<a href="#ref-7">7</a>]</span>, RDFa <span class="references">[<a href="#ref-8">8</a>]</span>, Turtle <span class="references">[<a href="#ref-9">9</a>]</span>, N-Triples <span class="references">[<a href="#ref-10">10</a>]</span> and JSON-LD <span class="references">[<a href="#ref-11">11</a>]</span>. Each of these formats have their advantages and drawbacks, a detailed comparison is provided further in this section. Additionally, it is possible to receive data from various sources, such as databases. This section elaborates how this data can be transformed into RDF data so that it can be used for Linked Data querying.</p>

      <h3 id="formatting-RDF">Resource Description Format (RDF)</h3>
      <p>Before considering the different formats to serialize RDF data, the RDF framework is described. The purpose of RDF is to create a general method to describe resources and relations between data objects, without making any assumptions regarding the domain. The concept of RDF originates from the problem that the World Wide Web was made to be interpreted by humans instead of machines. RDF proves to be an effective way of integrating information of different sources by decoupling the information from its original scheme. In other words, RDF aims to make the Web interpretable by machines <span class="references">[<a href="#ref-2">2</a>]</span>.</p>

      <p>One of the new features introduced in <a href="https://www.w3.org/TR/rdf11-concepts/">RDF 1.1</a> is the concept of named graphs. Since RDF 1.1, an RDF dataset may have multiple named graphs and at most one unnamed default graph. This enables grouping the data and as such giving extra context about how certain elements of the data are related <span class="references">[<a href="#ref-12">12</a>]</span>. Subsequently, named graphs make it possible to both assign a URI to a collection of triples, and to create statements on the whole set.</p>

      <h3 id="data-model">Data model</h3>
      <figure id="RDF">
<img src="images/spo.svg" alt="[RDF statement]" />
<figcaption>
          <p><span class="label">Fig. 2:</span> Visualization of an RDF triple as a directed graph. This shows how a triple connects two labeled graph nodes via a directed labeled edge.</p>
        </figcaption>
</figure>

      <p>RDF is structured as a collection of triples. These triples can be visualized as a node-arc-node link, which consists of a subject, a predicate, and an object (<a href="#RDF">Fig. 2</a>). Thus this collection of triples can be interpreted as a graph, with the arc pointing towards the object <span class="references">[<a href="#ref-13">13</a>]</span>.</p>

      <p>An RDF triple represents a simple sentence. A commonly used example is the triple (<code>Alice - Knows - Bob</code>), which means that the subject ‘‘Alice’’, knows the object of the triple ‘‘Bob’’.</p>

      <h3 id="serialization-format">Serialization format</h3>
      <p>When reasoning about RDF, it is important to note that RDF itself is not a data format, but a data model. This model describes that the data should be represented as a triple, in the form of <code>subject - predicate - object</code>. Hence, to publish an RDF graph, it must be serialized using an RDF syntax <span class="references">[<a href="#ref-14">14</a>]</span>. Some of the standardized syntaxes are described below, each with the corresponding notation of the <code>Alice - Knows - Bob</code> example.</p>

      <h4 id="rdfxml">RDF/XML</h4>

      <p>The <em>RDF/XML</em> syntax is the original RDF serialization format to publish Linked Data on the web. This syntax presents the RDF data model using XML (<a href="#rdfxml-example">Listing 1</a>). However, the popularity of this syntax is decreasing, because it is difficult for humans to interpret and write <span class="references">[<a href="#ref-7">7</a>]</span>.</p>

      <figure id="rdfxml-example" class="listing">
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</code><code>&lt;rdf:RDF
</code><code>   xmlns:foaf=&quot;http://xmlns.com/foaf/0.1/&quot;
</code><code>   xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;
</code><code>&gt;
</code><code>  &lt;rdf:Description rdf:about=&quot;http://example.org/alice&quot;&gt;
</code><code>    &lt;foaf:knows rdf:resource=&quot;http://example.org/bob&quot;/&gt;
</code><code>  &lt;/rdf:Description&gt;
</code><code>&lt;/rdf:RDF&gt;</code></pre>
<figcaption>
          <p><span class="label">Listing 1:</span> RDF/XML representation of the <code>Alice - Knows - Bob</code> example.</p>
        </figcaption>
</figure>

      <h4 id="turtle-and-trig">Turtle and TriG</h4>

      <p><em>Turtle</em> is a serialization format for RDF data that exposes the data in plain text. This format provides prefixes for namespaces and other abbreviations. These prefixes are described at the top of the document. Additionally with Turtle, every triple has to end with either one of three defined suffixes. The first suffix is a comma (<code>,</code>). This suffix indicates that the next triple has the same <em>subject</em> and <em>predicate</em> as the current triple, requiring nothing but the object on the next line. Alternatively, when a triple ends in a semicolon (<code>;</code>), the next triple has the same subject (but a different predicate) as the current one. Finally, a triple can have a dot (<code>.</code>) as its suffix. This suffix signals that the following triple does not have anything in common with the current triple. The abbreviations of Turtle are non-mandatory. As far as legibility is concerned, Turtle is considered one of the most readable and writable formats <span class="references">[<a href="#ref-9">9</a>]</span>. This is illustrated in <a href="#turtle-example">Listing 2</a>.</p>

      <p>TriG is an extension of Turtle. Just like Turtle, TriG defines a textual syntax for RDF that allows an RDF dataset to be written in a compact and natural text form. TriG extends the functionalities of Turtle by bringing the possibility to group triples into multiple graphs. Furthermore, these named graphs (as described in <a href="#formatting-RDF">RDF</a>) can be preceded by their names. This is so important because named graphs are a key concept of the Semantic Web <span class="references">[<a href="#ref-15">15</a>]</span>.</p>

      <figure id="turtle-example" class="listing">
<pre><code>@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
</code><code>
</code><code>&lt;http://example.org/alice&gt; foaf:knows &lt;http://example.org/bob&gt; .</code></pre>
<figcaption>
          <p><span class="label">Listing 2:</span> Turtle representation of the <code>Alice - Knows - Bob</code> example, from W3.org<sup id="fnref:rdf-example" role="doc-noteref"><a href="#fn:rdf-example" class="footnote">5</a></sup>.</p>
        </figcaption>
</figure>

      <h4 id="n-triples">N-Triples</h4>

      <p>The N-Triples format (visualized in <a href="#ntriples-example">Listing 3</a>) is a subset of Turtle that lacks support for prefixes and abbreviations. Consequently, this format is susceptible to both redundancies and larger file sizes when compared to Turtle. However, this redundancy also has an advantage: it allows line-by-line processing of N-Triples files. This allows for random access, straightforward compression, and usage in streaming contexts. Currently, the format is mostly used for files that are too big to fit into memory <span class="references">[<a href="#ref-10">10</a>]</span>.</p>

      <figure id="ntriples-example" class="listing">
<pre><code>&lt;http://example.org/alice&gt; &lt;http://xmlns.com/foaf/0.1/knows&gt; &lt;http://example.org/bob&gt; .</code></pre>
<figcaption>
          <p><span class="label">Listing 3:</span> N-Triples representation of the <code>Alice - Knows - Bob</code> example.</p>
        </figcaption>
</figure>

      <h4 id="formatting-json-ld">JSON-Linked Data (JSON-LD)</h4>

      <p>JSON-LD is a lightweight Linked Data format, based on the widely used JavaScript Object Notation (JSON) format for formatting data. Because of this and because of its popularity, legibility, and writability, JSON-LD is the ideal format to pass Linked Data in a programming environment. Because JSON-LD uses the same syntax as JSON, it can easily be used to parse and manipulate RDF data <span class="references">[<a href="#ref-11">11</a>]</span>. An example of this syntax is provided in <a href="#jsonld-example">Listing 4</a>.</p>

      <figure id="jsonld-example" class="listing">
<pre><code>[
</code><code>  {
</code><code>    &quot;@id&quot;: &quot;http://example.org/alice&quot;,
</code><code>    &quot;http://xmlns.com/foaf/0.1/knows&quot;: [
</code><code>      {
</code><code>        &quot;@id&quot;: &quot;http://example.org/bob&quot;
</code><code>      }
</code><code>    ]
</code><code>  }
</code><code>]</code></pre>
<figcaption>
          <p><span class="label">Listing 4:</span> JSON-LD representation of the <code>Alice - Knows - Bob</code> example.</p>
        </figcaption>
</figure>

      <h4 id="rdf-in-webpages">RDF in webpages</h4>

      <p>Multiple formats can be used to embed RDF triples into existing webpages on the internet. The first format is RDFa, which integrates RDF triples into Hypertext Markup Language (HTML) documents by binding the RDF triples with the HTML Document Object Model (DOM). This means that the existing content of pages is shown, thanks to RDFa, inside the HTML code. Because of this, the structured data is exposed to the web <span class="references">[<a href="#ref-8">8</a>]</span>, as shown in <a href="#rdfa-example">Listing 5</a>.</p>

      <figure id="rdfa-example" class="listing">
<pre><code>&lt;div xmlns=&quot;http://www.w3.org/1999/xhtml&quot;
</code><code>  prefix=&quot;
</code><code>    foaf: http://xmlns.com/foaf/0.1/
</code><code>    rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns#
</code><code>    rdfs: http://www.w3.org/2000/01/rdf-schema#&quot;
</code><code>  &gt;
</code><code>  &lt;div typeof=&quot;rdfs:Resource&quot; about=&quot;http://example.org/alice&quot;&gt;
</code><code>    &lt;div rel=&quot;foaf:knows&quot; resource=&quot;http://example.org/bob&quot;&gt;&lt;/div&gt;
</code><code>  &lt;/div&gt;
</code><code>&lt;/div&gt;</code></pre>
<figcaption>
          <p><span class="label">Listing 5:</span> RDFa representation of the <code>Alice - Knows - Bob</code> example.</p>
        </figcaption>
</figure>

      <p>Another option is to use Microdata. This format augments HTML webpages with specific machine-readable labels. It allows nested groups (items) of name-value pairs to be added to documents in addition to the existing content. To create an item, the <code>itemscope</code> attribute is used. An extra property can be added to an item with the <code>itemprop</code> attribute <span class="references">[<a href="#ref-16">16</a>]</span>. This practice is demonstrated in <a href="#microdata-example">Listing 6</a>.</p>

      <figure id="microdata-example" class="listing">
<pre><code>&lt;div&gt;
</code><code>  &lt;div itemtype=&quot;http://www.w3.org/2000/01/rdf-schema#Resource&quot; itemid=&quot;http://example.org/alice&quot; itemscope&gt;
</code><code>    &lt;link itemprop=&quot;http://xmlns.com/foaf/0.1/knows&quot; href=&quot;http://example.org/bob&quot; /&gt;
</code><code>  &lt;/div&gt;
</code><code>&lt;/div&gt;</code></pre>
<figcaption>
          <p><span class="label">Listing 6:</span> Microdata representation of the <code>Alice - Knows - Bob</code> example.</p>
        </figcaption>
</figure>

      <p><a href="#formatting-json-ld">JSON-LD</a> snippets can be used to structure data into HTML as well. This method uses a JavaScript notation, embedded in a <code>script</code> tag. In other words, within the <code>script</code> tag, additional data can be represented in a structured format, using JSON-LD.</p>

      <h4 id="comma-separated-values-csv-on-the-web">Comma-Separated Values (CSV) on the web</h4>

      <p>CSV is a popular format for publishing data. It is understandable by both humans and machines and it is typically presented in a table because of its structured format. Additionally, CSV data can easily be transformed into RDF data. However, one of the disadvantages of CSV is the absence of a mechanism to indicate the datatype of a specific column, which makes the data hard to validate. CSV on the Web solves this problem by augmenting the dataset with metadata that allows the publisher to provide additional information about the data <span class="references">[<a href="#ref-17">17</a>]</span>. <a href="#csvw-example">Listing 7</a> illustrates how the format of a country code field can be specified.</p>

      <figure id="csvw-example" class="listing">
<pre><code>{
</code><code>    &quot;titles&quot;: &quot;country&quot;,
</code><code>    &quot;datatype&quot;: {
</code><code>      &quot;dc:title&quot;: &quot;Country Code&quot;,
</code><code>      &quot;dc:description&quot;: &quot;Country codes as specified in ISO 3166.&quot;,
</code><code>      &quot;base&quot;: &quot;string&quot;,
</code><code>      &quot;format&quot;: &quot;[a-z]{2}&quot;
</code><code>    }
</code><code>  }</code></pre>
<figcaption>
          <p><span class="label">Listing 7:</span> CSV on the Web example of a country code field specification, from W3.org<sup id="fnref:csvw-w3-example" role="doc-noteref"><a href="#fn:csvw-w3-example" class="footnote">6</a></sup>.</p>
        </figcaption>
</figure>

      <h4 id="protocol-buffers">Protocol Buffers</h4>

      <p>Protocol Buffers are a technique developed by Google, designed for serializing structured data. Protocol Buffers aim to offer an interface description language for data, which is both simple and offers high performance. The data structures (referred to as messages) and services are described in ‘‘proto definition files’’, which are programming language-agnostic. Subsequently, Google provides code generators that allow generating source code in multiple different programming languages from these definition files. To achieve high performance, the messages are serialized into a binary format for transmission. This makes them both compact and forward- and backward-compatible. Backward compatibility means that a change in the technology will not break older versions. Forward compatibility on the other hand, means that a file from a more recent version can still be processed by older versions. A disadvantage of Protocol Buffers might be that it was developed for internal use, thus it was not optimized for unpredictable data (such as Linked Data) <span class="references">[<a href="#ref-18">18</a>]</span>.</p>

      <p>In addition to Protocol Buffers, Google has also developed Flat Buffers. These offer access to the serialized data without requiring parsing or unpacking. Furthermore, Flat Buffers focus on memory efficiency, speed, flexibility, a tiny code footprint, strong types and ease-of-use. Flat Buffers work with cross-platform code without dependencies. However, this technology does not seem very useful for Linked Data, because it conflicts with the key principles of Linked Data by enforcing a scheme. Therefore, this is not further discussed in this paper <span class="references">[<a href="#ref-19">19</a>]</span>.</p>

      <h4 id="header-dictionary-triples-hdt">Header Dictionary Triples (HDT)</h4>

      <p id="formatting-hdt">HDT is a binary format to represent RDF data in a compact way. An HDT file combines three parts. The first part is the header, which provides metadata about the dataset in a plain RDF format. The second part is the dictionary, which brings a mapping between strings and unique identifiers. The last part contains the triples and encodes the RDF graph using unique identifiers <span class="references">[<a href="#ref-20">20</a>]</span>.</p>

      <h3 id="rdf">RDF*</h3>
      <p>RDF* (pronounced as ‘‘RDF star’’) is an extension to the Resource Description Framework, which enables RDF graphs to represent interactions and attributes by embedding triples. By nesting triples, an entire triple can become the subject of a second triple. This eliminates the need for intermediary entities, making the model easier to understand. Even though RDF* offers many benefits, it is still under consideration by the W3C and is not yet officially accepted as a standard.</p>

      <h3 id="formatting-decoupling">Decoupling data</h3>
      <p>Since RDF is used to decouple data from its scheme, it should be possible to receive an arbitrary dataset (structured as e.g. CSV, XML, JSON or in a database), and transform this into an RDF format. To facilitate this, the RDF Mapping Language (RML) is used to materialize data into RDF triples.</p>

      <p>RML is defined to express customized mapping rules from heterogeneous data structures and serializations to the RDF data model. Furthermore, RML is a superset of the W3C-standardized mapping language (R2RML). RML provides a generic way of defining the mappings that is easily transferable to cover references to other data structures. Thus, RML is a generic approach, but offers case-specific extensions. This makes it possible to transform any input (e.g., CSV, JSON, relational databases, etc.) into RDF data <span class="references">[<a href="#ref-21">21</a>]</span>.</p>

    </div>
</section>

  <section id="linked-data" inlist="" rel="schema:hasPart" resource="#linked-data">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Linked Data</h2>

      <p>One of the most critical aspects of the Semantic Web is the ability to create links between multiple datasets. These links are described in a standardized framework, RDF, as previously described in <a href="#formatting-RDF">Subsection 3.1</a>. Not only do these links allow humans to traverse the web, but they also provide a similar pathway for machines to traverse the web as well.</p>

      <p>To qualify as Linked Data, the following four conditions need to be met <span class="references">[<a href="#ref-1">1</a>]</span>:</p>

      <ol>
        <li>Objects have to be identified through a unique resource identifier (URI).</li>
        <li>These URIs have to be HTTP URIs.</li>
        <li>Data has to be found when we follow such a URI. This data can be formatted in many ways, such as XML.</li>
        <li>The data has to include links to other data. These links are vital to establishing a ‘‘web’’ of data.</li>
      </ol>

      <p>A simple way to represent Linked Data is by using a directed graph, such as visualized in <a href="#LinkedData">Fig. 3</a>. In this figure, the vertices represent objects or data points, whereas the edges represent the links that connect objects or data points. Among other things, this example visualizes the aforementioned <code>Alice - Knows - Bob</code> relation. Additionally, the object Alice has a <code>Name</code>-link to a data point with the value ‘‘Alice’’. From this, we can infer that the name of the object is Alice.</p>

      <p>Finally, observe that every object has at least one link, which implies a connected ‘‘Web of Data’’.</p>

      <figure id="LinkedData">
<img src="images/linked-data.svg" alt="[Linked Data]" />
<figcaption>
          <p><span class="label">Fig. 3:</span> Example of a linked data web.</p>
        </figcaption>
</figure>

      <h3 id="sparql">SPARQL</h3>

      <p>SPARQL <span class="references">[<a href="#ref-22">22</a>]</span> (a recursive acronym that stands for the SPARQL Protocol and RDF Query Language) is a semantic query language that allows to query and edit data stored in the RDF format. It is the standard query language for RDF and was adopted by W3C<sup id="fnref:w3c" role="doc-noteref"><a href="#fn:w3c" class="footnote">7</a></sup> as a recommendation in 2008. SPARQL is similar to SQL<sup id="fnref:sql" role="doc-noteref"><a href="#fn:sql" class="footnote">8</a></sup>, but where SQL operates on relational databases, SPARQL operates on the Semantic Web. While the functionality is not completely the same, the style of querying for information is very similar, as shown in <a href="#sparql-example">Listing 8</a>.</p>

      <figure id="sparql-example" class="listing">
<pre><code>PREFIX foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;
</code><code>SELECT ?name
</code><code>WHERE {
</code><code>    ?person foaf:name ?name .
</code><code>}</code></pre>
<figcaption>
          <p><span class="label">Listing 8:</span> SPARQL example that lists the names of all the objects that have this link, from W3.org<sup id="fnref:sparql-w3-example" role="doc-noteref"><a href="#fn:sparql-w3-example" class="footnote">9</a></sup>.</p>
        </figcaption>
</figure>

    </div>
</section>

  <section id="versioning" inlist="" rel="schema:hasPart" resource="#versioning">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Data versioning</h2>

      <p>Data versioning has two main advantages for both the data consumers and the providers. The first advantage for consumers is the ability to consider only data in a specified timeframe of interest. For example, a train schedule application does not require information about interruptions and delays from a month ago. Versioning allows the provider to define so-called ‘‘snapshot’’ versions, which correspond to checkpoints of the dataset. Consumers can reconstruct subsequent versions of the dataset by fetching only the introduced changes (<em>deltas</em>), since a given snapshot. The benefit of publishing these deltas is that the consumers do not need to download the entire dataset every time an update is published, they can download only the changes. For the providers, storing these deltas eliminates the need to store duplicate or redundant information.</p>

      <h3 id="git-based">Git-based</h3>
      <p>The first type of approach that is discussed is derived from the world of software engineering. Software developers use version control systems, such as Git or Mercurial, to work on the same source code files collaboratively. The same idea can be used to version data, as proposed by Arndt et al. <span class="references">[<a href="#ref-23">23</a>]</span>. This paper formalizes the requirements for a git-based data versioning infrastructure as follows:</p>

      <ol>
        <li>
          <p><strong>Support divergence of datasets:</strong> 
The more users that contribute to the dataset, the higher the probability that some users disagree on how the dataset should evolve. Consider for example a dataset of train connections in Belgium. The set of contributors might be divided into smaller working groups, each with their dedicated focus. Some users might prefer to work on train stations in Ghent, others in Antwerp, etc. This concept corresponds to <em>branches</em> in Git.</p>
        </li>
        <li>
          <p><strong>Conflate diverged datasets:</strong>
Once the working groups have finished their subtasks, they should be able to integrate their changes back into the upstream dataset. This is achieved through a <em>merging</em> process, similar to Git. When merging two branches, conflicts may arise in case other branches that touch the same data have already been integrated. The system must support both conflict detection and resolution to prevent compromising data integrity.</p>
        </li>
        <li>
          <p><strong>Synchronization of derivatives:</strong>
To enable distribution of the dataset across multiple servers, a synchronization mechanism is required to ensure every device has a consistent version of the dataset. In Git, this corresponds to having both a local copy of the repository and a remote repository (via e.g. <a href="https://github.com/">GitHub</a>). Subsequently, the local dataset can be updated via <em>pull</em> operations, whereas local changes can be <em>pushed</em> to the remote repository.</p>
        </li>
      </ol>

      <h3 id="rdf-archives">RDF archives</h3>
      <p>Another approach that is gaining increased interest among researchers, is RDF archives <span class="references">[<a href="#ref-24">24</a>, <a href="#ref-25">25</a>]</span>. This approach describes a technique for archiving RDF data and executing queries on those archives. RDF archives entail six different query types and three different storage strategies.</p>

      <h4 id="query-atoms">Query atoms</h4>
      <p>The corresponding literature currently distinguishes six different types of queries, called <em>Query atoms</em>. These are explained below using the example of a car park.</p>

      <ol>
        <li>
          <p><strong>[VM] Version materialization:</strong>
The first type of query is the most basic form of retrieval. Version materialization allows the consumer to obtain the complete state of the dataset at a given timestamp or version, similar to the earlier discussed <em>snapshots</em>. Note that this technique is also being used by existing web archiving services, such as the <a href="https://web.archive.org/">WayBack Machine of the Internet Archive</a>. In the context of the car park example, this is equivalent to listing all cars that are in the car park at the given timestamp.</p>
        </li>
        <li>
          <p><strong>[DM] Delta materialization:</strong>
Subsequently, the consumer might be interested in obtaining the differences between two versions. This request is fulfilled using the second type of query. In order to enable this functionality, the system must support conflating several deltas into a new version to calculate the net differences. In the car park example, this would allow the consumer to retrieve a list of all cars that have entered the car park today.</p>
        </li>
        <li>
          <p><strong>[SVQ] Single-version structured queries:</strong>
Next, literature considers the evaluation of complex queries on one specific version of the dataset. This functionality is currently offered by <a href="#sparql">SPARQL</a> endpoints. An example query on the example situation could be: ‘‘is there a blue car in the car park on January 1, 2020?’’.</p>
        </li>
        <li>
          <p><strong>[SDQ] Single-delta structured queries:</strong>
The same analogy as with the first and second type of query can also be applied here. As an example, consider the following query: ‘‘has a blue car entered the car park today?’’.</p>
        </li>
        <li>
          <p><strong>[CVQ] Cross-version structured queries:</strong>
The fifth type is very similar to the third type, except that the goal is to query across multiple versions at once. The aforementioned example query can be slightly adapted as follows: ‘‘has there ever been a blue car in the car park?’’.</p>
        </li>
        <li>
          <p><strong>[CDQ] Cross-delta structured queries:</strong>
Finally, the previous query type also has a delta counterpart. The above query can also be modified to serve as an example for this type: ‘‘on average, how many cars enter the car park per day?’’.</p>
        </li>
      </ol>

      <h4 id="versioning-rdfarchives-storage">Storage</h4>
      <p>Depending on which query atoms should be optimized, a different storage strategy is preferred.</p>

      <ol>
        <li>
          <p><strong>[IC] Independent Copies:</strong>
The first technique simply creates a separate, isolated instance of the entire dataset every time a change is introduced. The advantage of this storage technique is high performance for <code>VM</code>, <code>SVQ</code> and <code>CVQ</code> queries, but the downside is twofold. First of all, the duplication of the datasets inevitably incurs scalability issues. Additionally, since deltas do not exist, these must be calculated on-the-fly in order to evaluate delta-oriented queries. This task might be computationally expensive.</p>
        </li>
        <li>
          <p><strong>[CB] Change-based approach:</strong>
The second technique relates more to the aforementioned Git-based approaches. This technique starts from an empty dataset and stores the changes (deltas). Consequently, this strategy addresses the scalability issues of the previous approach. Furthermore, this technique is very efficient to evaluate delta-based queries (<code>DM</code>, <code>SDQ</code>, <code>CDQ</code>), but requires these deltas to be conflated every time a version-based query is evaluated.</p>
        </li>
        <li>
          <p><strong>[TB] Timestamp-based approach:</strong>
The final strategy augments the stored triples with temporal validity information and acts therefore as a combination of the two other strategies. This approach supports compression to reduce space and can be used for all queries except <code>DM</code>.</p>
        </li>
      </ol>

      <h4 id="ostrich">OSTRICH</h4>
      <p>In addition to the above three storage techniques, <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1145/3184558.3186960"><a href="https://doi.org/10.1145/3184558.3186960">Taelman et al.</a></span> <span class="references">[<a href="#ref-26">26</a>, <a href="#ref-27">27</a>]</span> proposes <em>OSTRICH</em> as a versioned ‘‘hybrid IC-CB-TB’’ storage mechanism. Because of this, OSTRICH is able to efficiently evaluate <code>VM</code>, <code>DM</code>, <code>SVQ</code> and <code>CVQ</code> queries and return the results as a stream of triples. Being a hybrid storage mechanism, the working of OSTRICH is inspired by combining the best properties and ideas of the previously discussed techniques. First, an immutable copy of the dataset is made, which serves as the initial version. This version is saved as an <a href="#formatting-hdt"><code>HDT</code>-file</a>. This format is a binary RDF representation that features both a high compression ratio, as well as indices to ‘‘enable the efficient execution of triple pattern queries and count estimation’’. All subsequent updates to the dataset are stored as deltas, which are also indexed and merged according to their timestamp to consume less disk space.</p>

      <p>The advantage of using OSTRICH over the aforementioned Git-based approach is that OSTRICH makes it possible to execute version-based queries, without requiring a materialization step. This vastly speeds up the entire query.</p>
    </div>
</section>

  <section id="delivery" inlist="" rel="schema:hasPart" resource="#delivery">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Data delivery</h2>

      <p>In this section, the transmission of the data to the users is discussed. After the previous sections have described how data can be stored, the next problem that arises is how to expose it for consumers to access. The most commonly used protocol for web data exchange is HTTP, which uses a <code>request-response</code> communication pattern, in which an HTTP server answers to the requests of a client sequentially. However, this might not be the most optimal form of communication in the context of this paper, since this requires the consumer to send a request each time an update is desired. Consider on the other hand the <code>publish-subscribe</code> pattern, in which updates are pushed to the consumer (<em>subscriber</em>) automatically when they are available, without requiring an explicit intent from the consumer. This pattern is implemented in the MQTT protocol and in existing software such as Apache Kafka, which employs a similar strategy and uses a custom protocol directly over TCP.</p>

      <p>However, the MQTT protocol is not the silver bullet for data delivery, since it is not built upon HTTP and it is not standardized by the W3C Web of Things either. Instead, it was designed for IoT (<em>Internet of Things</em>) applications, which concerns primarily machine-to-machine communication, not on the Web. The protocol itself is therefore not useful in this context, but the characteristics can be used.</p>

      <p>The existing HTTP protocol can still be a viable option since it can serve as the foundation on top of which a new protocol can be built. Alternatively, an already existing protocol with suitable characteristics can be adapted to better meet the needs of event-based processing.</p>

      <h3 id="delivery-approaches">Delivery Approaches</h3>

      <p>When devising a strategy to deliver a given Linked Open Dataset, some considerations must be taken into account. The first aspect is the partitioning of the data, which impacts how it can be transmitted. Secondly, since the goal is to work with event streams, the architecture should be decentralized. Finally, the strategy should offer storage and performance benefits that are comparable to using a centralized, data-dump style approach <span class="references">[<a href="#ref-28">28</a>]</span>.</p>

      <p>In the current state of the art, the nature of the data affects the transmission. In the case of real-time sensor data, for example, Atmoko et al. <span class="references">[<a href="#ref-29">29</a>]</span> describe an MQTT-based approach and indicate that this is more efficient than using regular HTTP. However, since the goal is to achieve a generic approach for each kind of data, elements of different technologies should be combined, so that both machines can consume the received data, but that it can also be consulted by humans in a browser.</p>

      <h3 id="low-level-protocols">Low-level protocols</h3>

      <p>Various low-level protocols exist, such as Message Queuing Telemetry Transport (MQTT), the Advanced Message Queuing Protocol (AMQP), or the Constrained Application Protocol (CoAP). These protocols are focused on the transmission of data on constrained, low-level devices. Wang <span class="references">[<a href="#ref-30">30</a>]</span> shows a similar conclusion when comparing MQTT and HTTP on data from IoT devices. Some datasets used by Van de Vyvere et al. <span class="references">[<a href="#ref-31">31</a>]</span> also consist of IoT data. While, in this context, the intention is not to use a lightweight, lower level protocol such as MQTT (instead the goal is to publish data on the web, using HTTP), it is valuable to look at what makes it the best option, i.e. the different communication model, and adapt the desired technology accordingly.</p>

      <p>Furthermore, low-level protocols such as MQTT suffer from security vulnerabilities<sup id="fnref:cve" role="doc-noteref"><a href="#fn:cve" class="footnote">10</a></sup>, which is problematic in the context of open data publishing. HTTP on the other hand, is well established, mainstream, and therefore less susceptible to the same kind of problems. Hence from a security point of view, it makes sense to prefer HTTP over low-level protocols.</p>

      <h3 id="http-based-approaches">HTTP-based approaches</h3>
      <p>Other options include the use of <em>web feeds</em>, such as RDF Site Summary (RSS). RSS publishes updates in a feed and allows users to access them in a standardized format<sup id="fnref:rssspec" role="doc-noteref"><a href="#fn:rssspec" class="footnote">11</a></sup>. However, RSS is an umbrella term that spans different formats. Therefore, Atom <span class="references">[<a href="#ref-32">32</a>, <a href="#ref-33">33</a>]</span> was created, to achieve more standardization and disambiguation. Atom uses a separate protocol on top of HTTP. These two similar approaches to data publishing can both be considered since the concept and use of web feeds are similar to the goal of the event-based approach.</p>

      <p><strong>Linked Data Notifications</strong> <span class="references">[<a href="#ref-34">34</a>, <a href="#ref-35">35</a>]</span> (LDN) is another protocol developed by the W3C. This protocol shares similarities with the aforementioned Kafka and MQTT technologies. Where Apache Kafka uses a <em>broker</em> as an intermediary service between Senders and Consumers, LDN uses an <em>inbox</em>.</p>

      <p>A <em>sender</em> can send a notification to a <em>receiver</em> using an HTTP <code>POST</code>-request. The receiver is then responsible for storing these in their inbox. When a consumer wants to fetch these notifications, they can send an HTTP <code>GET</code>-request to the URL of this inbox. The response to this request contains a listing of all the corresponding notifications. Each entry in the list must be formatted as an RDF source and contains a URI, which the consumer can subsequently use to query specific notifications from the inbox. According to the specification, each notification needs to at least be formatted with the JSON-LD <a href="#formatting-json-ld">Subsubsection 3.3.4</a> <code>Content-Type</code>, but additional serializations are allowed as well. This clearly shows the similarities with a system that uses brokers. However, LDN seems less focused on continuously updating data and speed and more on adaptability and the ability to use it in a variety of contexts <span class="references">[<a href="#ref-35">35</a>]</span>. Evaluating the performance of LDN, when speed is crucial, can be a topic for further research.</p>

      <figure id="LDN">
<img src="images/ldn.svg" alt="[LDN model]" />
<figcaption>
          <p><span class="label">Fig. 4:</span> Linked Data Notifications delivery model <span class="references">[<a href="#ref-35">35</a>]</span>. Note the different HTTP requests indicated using the arrows, as discussed in the text. Also note the discovery of the inbox and notifications using RDF predicates.</p>
        </figcaption>
</figure>

      <p>Van de Vyvere et al. <span class="references">[<a href="#ref-31">31</a>]</span> compare an HTTP polling approach with a push-based approach using <em>Server-Sent Events (SSE)</em> on live Open Datasets. The datasets that are used are real-time in nature and most of them are almost continuously updated. The authors clearly show that, in order to minimize latency on the client, a push-based approach is required. When using these approaches, the server keeps the connection to the client alive, so that multiple updates of the dataset can be sent over the same connection. This practice eliminates the need for costly handshakes when initiating new connections and consequently benefits the performance. In addition to SSE, the authors also consider <em>WebSockets</em>, which uses an HTTP handshake to initiate the channel, but further transmission occurs over a raw TCP connection that supports full-duplex bidirectional communication. SSE and WebSockets offer similar performance and since SSE is unidirectional and only reliant on HTTP, the former was chosen in this article. Moreover, the CPU usage of SSE in comparison to polling was also shown to decrease. In order to find a generic approach for all kinds of Linked Open Datasets, it is clear that some sort of pushing from the server should be supported to ensure support for fast-changing, continuously updating datasets.</p>

      <p id="delivery-websub"><strong>WebSub</strong> <span class="references">[<a href="#ref-36">36</a>]</span> is the last protocol considered in this section. This protocol was adopted by the W3C in 2018 and provides publish-subscribe communication using HTTP. Previously, this protocol was named <em>PubSubHubbub</em>, because it uses the concept of <em>hubs</em> as intermediary servers between publishers. These publishers own <em>topics</em> and push updates to them, whereas they can be subscribed to by <em>subscribers</em>. Subscribers need to be network-accessible at all times using their <em>Subscriber Callback URL</em>. In order to subscribe to a topic, the subscriber sends an HTTP <code>POST</code>-request to a hub that contains their callback URL. For publishers, however, the specification does not provide a standardized way to update the hubs, hence it can be chosen by the developers. When a hub receives an update from a publisher, it notifies the subscribers by relaying the updates to their specified callback URL. The specification recommends that HTTPS is used at all times for HTTP requests and also specifies an additional <code>X-Hub-Signature</code> header that can be used for message authentication. This protocol might be of interest since it inherently supports decentralization, namely, hubs can be partitioned according to the needs of the user and so can the topic (i.e. topics can be duplicated across different hubs or could only be present on certain hubs). The downside to this protocol is that the subscribers must always be reachable via HTTP, which implies that the subscriber must operate a web server, to which updates can be pushed.</p>

    </div>
</section>

  <section id="caching" inlist="" rel="schema:hasPart" resource="#caching">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Data caching</h2>

      <p>This section describes and compares various techniques in literature that can be used to enable caching of large open datasets. Multiple aspects of caching are considered, the first is an overview of pull- and push-based strategies to update caches, and to notify consumers of changes. Next, techniques to cache query results are discussed. This section is concluded by providing a case study of caching on the Web, more specifically in Content Delivery Networks.</p>

      <h3 id="caching-pullbased">Pull-based approaches</h3>

      <p>Many different algorithms exist to update large Open Data caches using pull-based approaches, with varying computational complexity. Dividino et al. <span class="references">[<a href="#ref-37">37</a>]</span> consider the following five elementary strategies:</p>

      <ol>
        <li><strong>Age:</strong> First update the oldest part of the dataset.</li>
        <li><strong>Size_SmallestFirst:</strong> First update the smallest part of the dataset.</li>
        <li><strong>Size_BiggestFirst:</strong> The opposite of the previous strategy, first update the biggest part of the dataset.</li>
        <li><strong>PageRank:</strong> Update the highest-ranked page in the dataset.</li>
        <li><strong>ChangeRatio:</strong> Update the part of the dataset that was changed the most (using set difference).</li>
      </ol>

      <p>In addition to these simple algorithms, Dividino et al. <span class="references">[<a href="#ref-37">37</a>]</span> propose two more complex techniques. These techniques each have two variants, one using the Jaccard distance (ending in <code>-J</code>) and the other one with the <code>-D</code> suffix which uses the Dice coefficient, taking into account the last two retrieved versions. The first algorithm is <em>ChangeRate</em>. This algorithm is similar to the simple <em>ChangeRatio</em> algorithm, but uses the Jaccard distance or Dice coefficient instead of set difference. Finally, the authors propose the <em>Dynamics-J</em> and <em>Dynamics-D</em> algorithms, that update the most dynamic data source. The authors conclude that these final four algorithms work better when there is limited bandwidth.</p>

      <p>Nishioka et al. <span class="references">[<a href="#ref-38">38</a>]</span> describe how the lifespan of RDF triples can be predicted and how these predictions can be used to update local caches. These predictions are obtained by training a linear regression model on different features of the RDF triple. The first feature is the <em>Pay-level domain (PLD)</em> of the subject. For example, the PLD of the subject <code>https:/​/​dbpedia.org/resource/Google</code> would be &#8220;https://dbpedia.org`. As a motivation for this choice, the authors state that triples from the same PLD will have a similar lifespan. Additionally, the predicate and the Pay-level domain of the object are used. If the object is a literal, rather than a URI, the literal value is used instead. When compared to taking the mean average of the frequencies in the training data to all triples in the test set, the predictions provided substantially better results. Using this predicted lifespan, the authors propose an algorithm to update a local cache based on the reciprocal of the mean average of a triple. This algorithm was compared with the best performing algorithm proposed by Dividino et al. <span class="references">[<a href="#ref-37">37</a>]</span>, which is the <em>Dynamics-J</em> algorithm. This comparison was done on the DyLDO and Wikidata datasets with a varying amount of bandwidth. For every bandwidth, both algorithms offer very similar precision, but the precision of the linear regression model is always higher than the <em>Dynamics-J</em> algorithm. This difference is the most significant when the bandwidth is low, in which the precision for the linear model is 0.998, whereas the Dynamics-J algorithm has a precision of 0.996. As the relative bandwidth increases, both algorithms achieve a precision of 100%. The authors conclude that their approach outperformed the methods proposed by Dividino et al. <span class="references">[<a href="#ref-37">37</a>]</span>, and that it requires fewer resources because the previous snapshots of the data are not required. Finally, the authors discussed more advanced machine learning models, which did not incur a significant improvement on the results.</p>

      <p>The final pull-based algorithm is <em>Application-Aware Change Prioritization (AACP)</em>, using the <em>Preference Aware Source Update (PASU)</em> strategy. This algorithm is proposed by Akhtar et al. <span class="references">[<a href="#ref-39">39</a>]</span> and combines a change metric and a weight function to identify the recent changes. The authors have compared their algorithm to the already existing solutions described in this section. This comparison has been done on the DyLDO and BTC datasets. When compared to the five elementary algorithms and the <em>ChangeRate</em> algorithm by Dividino et al. <span class="references">[<a href="#ref-37">37</a>]</span>, the authors found that their algorithm outperforms every algorithm with an effectivity of 93.5%, which is 8.8% higher than the second-ranked <em>ChangeRate</em> algorithm. Their algorithm was also compared to the aforementioned linear regression model by Nishioka et al. <span class="references">[<a href="#ref-38">38</a>]</span>, in which their algorithm has higher precision and a higher recall score than the linear model, for every iteration. This difference is the most significant during the first iteration, namely 0.03 for both precision and recall on the BTC dataset.</p>

      <h3 id="push-based-approaches">Push-based approaches</h3>
      <p>The approaches described in the previous section rely on pull-based mechanisms. Using these mechanisms, the client is responsible for updating their local cache themselves. Push-based approaches work differently, in the sense that the server notifies clients of changes in the dataset. The main advantage of this strategy is that the amount of unnecessary requests is reduced since clients do not need to poll for updates to the dataset. However, pushing updates to the clients will temporarily result in a bigger load on the server.</p>

      <p><span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1145/3184558.3191650"><a href="https://doi.org/10.1145/3184558.3191650">Rojas Meléndez et al.</a></span> <span class="references">[<a href="#ref-40">40</a>]</span> discuss the advantages of a <em>publish-subscribe</em> approach and use parking data in Flanders as a proof of concept. While the authors did not have a large enough dataset to verify their arguments, they still argue the ease of implementation of a push-based strategy.</p>

      <p>Finally, Van de Vyvere et al. <span class="references">[<a href="#ref-31">31</a>]</span> compare three metrics for an SSE approach and HTTP polling approaches (with and without nginx<sup id="fnref:nginx" role="doc-noteref"><a href="#fn:nginx" class="footnote">12</a></sup>). These metrics are latency (the amount of time it takes for an update to be registered by the consumer), memory usage, and CPU usage. The authors conclude that pull-based approaches always incur a higher latency than push-based approaches. On the other hand, more memory is required to use push-based approaches, because all connections to clients need to be kept alive in memory. The authors assumed that CPU usage would be better for a push-based approach initially, but that for a higher amount of consumers, the pull-based approaches would perform better. However, this hypothesis was rejected based on the results. Overall, their comparison shows that a push-based approach is generally the best choice. It is important to remark that the authors have used a simplistic pulling approach for this comparison, as opposed to the more complex approaches described in the previous section.</p>

      <h3 id="caching-query-results">Caching query results</h3>
      <p>The aforementioned approaches always assume that the entire dataset is stored at every consumer. However, if the dataset becomes too large, this is not a viable option. Alternatively, the results of queries can be cached instead. This section describes three approaches to achieve this.</p>

      <p>The first cache technique is proposed by Akhtar et al. <span class="references">[<a href="#ref-41">41</a>]</span>. This technique uses an adaptive cache replacement strategy that examines query patterns from clients, and prefetches the results of possible future queries accordingly. This study shows an average reduction of query times by 6.34% when compared to existing approaches such as LRU (Least Recently Used), LFU (Least Frequently Used) and SQC (SPARQL Query Caching).</p>

      <p>Secondly, Yi et al. <span class="references">[<a href="#ref-42">42</a>]</span> propose a two-layer caching mechanism. The first layer implements the Adaptive Replacement Cache-memory algorithm (ARC) and operates in memory. The purpose of this layer is to cache all the frequently used queries that are either not complicated, or for which the result set is small. The other cases are handled by the second layer. This layer is a key-value database that is only partially running in memory. The approach has been compared to existing techniques on the OLTP-trace test set. The results prove that the proposed method has a higher hit ratio, more specifically for a cache size of 1000 entries, an LRU approach has a 0.43134 hit rate, while the ARC algorithm achieves a 0.44938 hit rate.</p>

      <p>The final method for caching Linked Open datasets is the <em>CyCLaDEs</em> approach, proposed by Folz et al. <span class="references">[<a href="#ref-43">43</a>]</span>. This approach consists of a decentralized cache that uses a ‘‘neighborhood’’ of clients. Every client in the same neighborhood hosts related fragments in their cache. Subsequently, a new client will first contact clients in this neighborhood before querying the server. This idea assumes that clients that have had similar queries in the past will also perform similar queries in the future. The algorithm first constructs a random subset of clients and then selects the <code>k</code> clients that are the most similar, to compose a neighborhood. Each client uses an LRU cache with a fixed size. It might be useful to combine this decentralized cache system with the two layer cache mechanism described above. The authors conclude that their decentralized approach is able to handle a lot of queries that a single local cache would miss. Furthermore, the CyCLaDEs approach with ten neighbors was compared to existing caching approaches on the BSBM-1M dataset. In both cases, the local caches can handle 40% of the total requests, but in the CyCLaDEs approach, 22% of the requests could be served from the neighborhood. They propose that their method could indeed be used in applications where the load on the main server can be very high. The authors did not explicitly investigate this, but this can be compared in future work.</p>

      <h3 id="http-caching">HTTP Caching</h3>
      <p>Caching is used a lot on the Web, mostly in the form of HTTP caching. Given the many different HTTP methods that exist, it only makes sense to cache <em>safe</em> requests that do not modify the state of the server, since these cannot invalidate the data. The most prominent examples of these requests are <code>HEAD</code>, <code>GET</code>, and <code>OPTIONS</code> requests, of which <code>GET</code> requests are the most common. In order to indicate how a request can be cached, the server can include a <code>Cache-Control</code> header in the response. This response has several possible values, multiple can be combined.</p>

      <ol>
        <li><strong>no-store:</strong> This response may not be cached by the client.</li>
        <li><strong>no-cache:</strong> This response may be cached by the client, but every time it is requested, the client must send a <code>HEAD</code> request to the server to validate whether the cached result is still up to date.</li>
        <li><strong>private:</strong> This response may only be cached in a web browser and not on intermediate servers. This option can for example be used when the data is confidential.</li>
        <li><strong>public:</strong> Every server (including intermediaries) may cache this response.</li>
        <li><strong>max-age=x:</strong> The response may be cached for at most <code>x</code> amount of seconds, without revalidating.</li>
        <li><strong>must-revalidate:</strong> The response must be revalidated every time it is requested.</li>
      </ol>

      <p>In addition to the <code>Cache-Control</code> header, the server may include an <em>etag</em> in the response that is calculated as a hash of the content. When sending this request again in the future, the client can include an <code>If-Modified</code> header with this etag as its value. If the server detects that the etag is still valid for the current version of the dataset, it sends an <code>HTTP 304 Not Modified</code> status code, indicating that the cached copy of the client is up to date.</p>

      <p>If no caching headers are present in the response, the client may use a heuristic that evicts the response from its cache when 10% of the difference in time between the current timestamp and the timestamp in the <code>Last-Modified</code> header is elapsed. This can be compared to previously discussed dynamic based algorithms. If a cached document is expired, the client can either send the <code>GET</code> request again and cache the new response, or send a lightweight <code>HEAD</code> request to validate the state.</p>

      <p>Note that HTTP caching only uses age or dynamics, which corresponds to the pull-based approaches described in <a href="#caching-pullbased">Subsection 7.1</a>. It was argued that push-based approaches had a better performance, which is why we propose that further research is required towards applying push-based approaches in HTTP communication.</p>

      <h3 id="caching-in-content-delivery-networks">Caching in Content Delivery Networks</h3>
      <p>An example of an intermediary in HTTP caching is a <em>Content Delivery Networks (CDN)</em>, which distributes cached copies of webpages over multiple servers that are located around the world. As a result, the perceived performance of a website no longer depends on the distance of the client to the server. Since these networks rely heavily on state of the art caching strategies, it is worth investigating scientific literature that considers Content Delivery Networks and try to apply the findings to Linked Open Data.</p>

      <!-- Not "Berget et al.", it's one person -->
      <p>The first technique is proposed by <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1145/3286062.3286082"><a href="https://doi.org/10.1145/3286062.3286082">Berger</a></span> <span class="references">[<a href="#ref-44">44</a>]</span> and concerns a supervised learning technique to train a lightweight boosted decision tree, using calculated <em>optimal decisions (OPT)</em> from the past. This model is subsequently used to update the cache in the present, a technique called <em>Learning from OPT (LFO)</em>. The authors state that this model achieves an accuracy of 93% in predicting the OPT decisions, but there is a 20% gap in caching performance between OPT and LFO. So even though the model predicts the best decision in 93% of the cases, its caching performance is significantly lower than the most optimal model. We argue that this method could also be applied as a caching strategy for query results caches of linked open data, but it still needs to be compared to other strategies described in the previous sections.</p>

      <p>Current cache replacement algorithms mostly consider the frequency and locality of data. <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1109/ICPADS.2012.106"><a href="https://doi.org/10.1109/ICPADS.2012.106">Li et al.</a></span> <span class="references">[<a href="#ref-45">45</a>]</span> propose to use the access interval change rate as an alternative metric to update caches. In this work, a naive algorithm is implemented that uses this access interval change rate and compares it to basic algorithms such as LRU and LFU. The authors show that using the access interval change rate results in a better caching performance. While this method is fairly simple, it is very performant. Combined with the conclusions from <a href="#caching-pullbased">Subsection 7.1</a>, we, therefore, conclude that these algorithms are beneficial if a simple strategy is needed, but that even better performance can be achieved with more complex algorithms.</p>

    </div>
</section>

  <section id="data-streaming" inlist="" rel="schema:hasPart" resource="#data-streaming">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Data streaming</h2>
      <p>In this final section, different aspects are highlighted on how to maintain a stream of linked data. The first section presents a vision that compares the distributed storage of linked data with the current way of storing DNS records, through the use of intermediaries. The subsequent sections describe existing techniques specifically tailored towards linked data streaming, in the context of the earlier discussed formatting, versioning, delivery, and caching methods.</p>

      <h3 id="use-of-intermediaries">Use of intermediaries</h3>
      <p>Remark that we can observe an interesting correlation between chaining SPARQL endpoints and the distribution of datasets, versus the mechanics of <em>Domain Name Servers (DNS)</em>. These servers start from a <em>root</em> DNS server and delegate the request of the user through multiple intermediaries. The same idea can be applied when scaling linked data streams, or even linked datasets themselves. A root server could for example serve as an entry point for data publishers to push their data to, as well as for users to send their requests to. These requests can subsequently be routed via multiple intermediaries, depending on which part of the data is required. Consider, as an example, that we are interested in a stream of train delays for the Ghent-St. Pieters train station in Belgium. The root server could contain links to several intermediary servers that contain this data for each continent. The next level could divide this further into countries per continent, followed by a city-based level and eventually a station-based level. This way the distribution of the stream can even be scaled adaptively, depending on the need. This idea can be implemented using the topic-based strategy used in <a href="#delivery-websub">Unknown 13</a>.</p>

      <h3 id="rdf-stream-processing">RDF Stream Processing</h3>
      <p>The Internet of Things has caused a shift in the data landscape. Sensors publish data at high frequency into the cloud, so that it does not always make sense to use polling-based approaches. Instead, it is much more efficient to treat these values in a <a href="#delivery">push-based</a> streaming fashion <span class="references">[<a href="#ref-46">46</a>]</span>. To manage these data streams, Stream Processing Engines have seen the light. However, since the contents of the stream can be in all shapes and sizes, a Web of Data-counterpart was needed. This has lead to the creation of RDF Stream Processing techniques, which allow to process RDF-based data streams using various operations such as filtering and aggregating.</p>

      <h4 id="streaming-rdfsp-triplewave">TripleWave</h4>
      <p>TripleWave is an open-source framework that allows the creation and the publishing of RDF streams. In their requirements section, Mauri et al. <span class="references">[<a href="#ref-47">47</a>]</span> list seven requirements to which the framework must comply. The most interesting requirements are <code>R1</code> and <code>R2</code>, which respectively state that “TripleWave may use streams available on the Web as input” and that “TripleWave shall be able to process existing time-aware (RDF) datasets” (which could either be formatted as a stream or not). These requirements imply that the framework has conversion mechanisms to transform this data. The framework uses CSV and JSON connectors to convert existing web streams, as well as <a href="#formatting-decoupling">R2RML</a> for the generation of RDF streams.</p>

      <p>For consumption of the streams, the framework provides both a push-based and pull approach, using WebSockets, end users can subscribe to a TripleWave endpoint and get updates pushed to them. Alternatively, streams can also be published for the user to pull them.</p>

      <h4 id="web-stream-processors">Web Stream Processors</h4>
      <p><a property="schema:citation http://purl.org/spar/cito/cites" href="https://doi.org/10.5167/uzh-149682">Dell’Aglio et al.</a> <span class="references">[<a href="#ref-46">46</a>]</span> propose an infrastructure that is capable of handling <a href="#streaming-rdfsp-triplewave">TripleWave streams</a> as input, and impose seven requirements for a Web of Data Streams, called <em>Web Stream Processors (WeSP)</em>. These requirements are inspired by previous work from <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1145/1107499.1107504"><a href="https://doi.org/10.1145/1107499.1107504">Stonebraker et al.</a></span> <span class="references">[<a href="#ref-48">48</a>]</span>.</p>

      <ol>
        <li>
          <p><strong>Keep the data moving:</strong>
The first requirement is that <em>WeSP must prioritize active paradigms for data stream exchange, where the data supplier can push the stream content to the actors interested in it</em>. This means that instead of using polling-based approaches, data publishers must push updates to subscribers. This has been discussed in <a href="#delivery">Data delivery</a> and matches the findings for low latency updates by Van de Vyvere et al. <span class="references">[<a href="#ref-31">31</a>, <a href="#ref-40">40</a>]</span>, since streams with high frequency correspond to real-time data flows.</p>
        </li>
        <li>
          <p><strong>Stored and streamed data:</strong>
As a second requirement, <em>WeSP must enable the combination of streaming and stored data</em>. Stored data in this context refers to data which has been formatted using the open data standards described in <a href="#formatting">Data formatting</a>, such as RDF. Additionally, this data can be exposed and queried via existing SPARQL-endpoints. To allow both streaming and storing the data, one of the <a href="#versioning-rdfarchives-storage">RDF archive storage</a>-techniques can be used. Specifically for streaming-based data, the delta-related query atoms are the predominant use case and therefore a change-based approach should be preferred.</p>
        </li>
        <li>
          <p><strong>High availability, distribution and scalability:</strong>
Next, <a property="schema:citation http://purl.org/spar/cito/cites" href="https://doi.org/10.5167/uzh-149682">Dell’Aglio et al.</a> <span class="references">[<a href="#ref-46">46</a>]</span> require that <em>WeSP must enable the possibility to build reliable, distributed and scalable streaming applications</em>. Obtaining high availability is possible using either one of the provided <a href="#versioning">Data versioning</a> approaches. The Git-based approaches in particular allow a dataset to be distributed efficiently across multiple devices and therefore improve the scalability and reliability. Depending on the frequency of the updates, the reliability can be further improved through caching.</p>
        </li>
        <li>
          <p><strong>Operations on the stream content:</strong>
A subsequent requirement is that <em>WeSP must guarantee a wide range of operations over the streams</em>. As mentioned before, RDF Stream Processing requires that the stream can be filtered or aggregated and that the result is another stream, which can be observed. This can be implemented via SPARQL queries that receive streamed data as their input, apply the desired operation, and return a new output stream of the results. Multiple of these queries can be chained together, to obtain the desired output depending on the use case.</p>
        </li>
        <li>
          <p><strong>Accessible information about the stream.</strong>
In order to improve the accessibility of the data, <em>WeSP must support the publication of stream descriptions</em>. These stream descriptions can contain metadata, such as the expected update frequency and the expected size of the updates. This information can serve multiple purposes. If a Git-based approach would be used to store the data, the meta-information can indicate the parent version, which can subsequently be interpreted to update a local copy by resolving the deltas. Additionally, if applicable, <code>Expiry</code> timestamps can be added to benefit from <a href="#caching">Data caching</a>.</p>
        </li>
        <li>
          <p><strong>Stream variety support:</strong>
The penultimate requirement is that <em>WeSP should support the exchange of a wide variety of streams</em>. Since the web is of decentralized nature, we cannot define a single model and format to which all streams must adhere. Instead, every stream can have its own format, depending on the content type and publishing frequency. Various formats discussed in the <a href="#formatting">Data formatting</a> section can be used.</p>
        </li>
        <li>
          <p><strong>Reuse of technologies and standards:</strong>
Finally, <em>WeSP should exploit as much as possible existing protocols and standards</em>. A manifold of existing technologies and infrastructures already exist. In the context of <a href="#formatting">formatting</a>, <a href="#versioning">versioning</a>, <a href="#delivery">delivery</a>, and <a href="#caching">caching</a>, this paper has provided sufficient examples. These existing technologies should be reused whenever possible to encourage interoperability. While starting from scratch can often give good results on a local scale (e.g. devising a format that is specifically created for the particular use case of the data), but prevents the technology from being globally adopted.</p>
        </li>
      </ol>

    </div>
</section>

  <section id="conclusion" inlist="" rel="schema:hasPart" resource="#conclusion">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Conclusion</h2>
      <p>The goal of this paper was to investigate how existing technologies can be applied in the field of Linked Open Data to handle data streaming. We have performed a literature study and explained various techniques to define, version, distribute, and cache this data. Multiple existing and viable technologies have been described, and each section stressed that existing technologies could be combined to achieve better performance. A lot of research has been conducted at the protocol level, but further research at higher levels is recommended and may prove beneficial. Furthermore, it was noticed that existing pull-based algorithms, which perform better, have not yet been compared to a push-based approach. Finally, we propose that the technologies described in the different sections could be combined into a solution for distributing live open Linked Datasets with event streaming.</p>

      <p>However, every dataset is different and therefore requires a different approach. For example, a dataset with parking spot availabilities needs an approach that prioritizes the speed of distribution of data changes, while an address registry dataset needs to prioritize access to this dataset at different times. We concluded in each section that various techniques exist to solve the subtask discussed in that section. However, no silver bullet exists (yet) that solves the complete problem. Therefore, we conclude that an exhaustive solution must use a combination of existing techniques and that future research should not consider the subtasks in isolation, but instead focus on the end-to-end combination of these subtasks. The benefit of reusing existing technologies, rather than establishing new standards, is the interoperability with existing systems.</p>
    </div>
</section>

</main>

<footer><section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="#bizer2011linked" typeof="schema:Chapter">Bizer, C., Heath, T., Berners-Lee, T.: Linked data: The story so far. In: Semantic services, interoperability and web applications: emerging concepts. pp. 205–227. IGI Global (2011).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="https://www.w3.org/TR/1999/REC-rdf-syntax-19990222/" typeof="schema:CreativeWork">Lassila, O.: Resource Description Framework (RDF) Model and Syntax Specification. W3C, <a href="https://www.w3.org/TR/1999/REC-rdf-syntax-19990222/">https:/​/​www.w3.org/TR/1999/REC-rdf-syntax-19990222/</a> (1999).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="https://dx.doi.org/10.1007/978-3-642-33158-9_7" typeof="schema:CreativeWork">Phuoc, D., Parreira, J., Hauswirth, M.: Linked Stream Data Processing. Presented at the September (2012).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="#berners2001semantic" typeof="schema:Article">Berners-Lee, T., Hendler, J., Lassila, O.: The semantic web. Scientific american. 284, 34–43 (2001).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="https://www.w3.org/2003/Talks/0922-rsoc-tbl/" typeof="schema:CreativeWork">Berners-Lee, T.: WWW Past, present and future. <a href="https://www.w3.org/2003/Talks/0922-rsoc-tbl/">https:/​/​www.w3.org/2003/Talks/0922-rsoc-tbl/</a> (2005).</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="https://commons.wikimedia.org/w/index.php?title=File:Semantic_web_stack.svg&amp;oldid=465885386" typeof="schema:CreativeWork">Commons, W.: File:Semantic web stack.svg — Wikimedia Commons, the free media repository. <a href="https://commons.wikimedia.org/w/index.php?title=File:Semantic_web_stack.svg&amp;oldid=465885386">https:/​/​commons.wikimedia.org/w/index.php?title=File:Semantic_web_stack.svg&amp;oldid=465885386</a> (2020).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="#manola2004rdf" typeof="schema:Article">Manola, F., Miller, E., McBride, B., others: RDF primer. W3C recommendation. 10, 6 (2004).</dd>
  <dt id="ref-8">[8]</dt>
  <dd resource="#herman2015rdfa" typeof="schema:CreativeWork">Herman, I., Adida, B., Sporny, M., Birbeck, M.: RDFa 1.1 Primer-Rich Structured Data Markup for Web Documents (2015).</dd>
  <dt id="ref-9">[9]</dt>
  <dd resource="https://www.w3.org/TR/2014/REC-turtle-20140225/" typeof="schema:CreativeWork">Carothers, G., Prud’hommeaux, E.: RDF 1.1 Turtle. W3C, <a href="https://www.w3.org/TR/2014/REC-turtle-20140225/">https:/​/​www.w3.org/TR/2014/REC-turtle-20140225/</a> (2014).</dd>
  <dt id="ref-10">[10]</dt>
  <dd resource="https://www.w3.org/TR/2014/REC-n-triples-20140225/" typeof="schema:CreativeWork">Carothers, G., Seaborne, A.: RDF 1.1 N-Triples. W3C, <a href="https://www.w3.org/TR/2014/REC-n-triples-20140225/">https:/​/​www.w3.org/TR/2014/REC-n-triples-20140225/</a> (2014).</dd>
  <dt id="ref-11">[11]</dt>
  <dd resource="#sporny2012json" typeof="schema:Article">Sporny, M., Longley, D., Kellogg, G., Lanthaler, M., Birbeck, M.: JSON-LD Syntax 1.0. W3C Community Group Final Specification. (2012).</dd>
  <dt id="ref-12">[12]</dt>
  <dd resource="https://www.w3.org/TR/2014/NOTE-rdf11-primer-20140624/" typeof="schema:CreativeWork">Raimond, Y., Schreiber, G.: RDF 1.1 Primer. W3C, <a href="https://www.w3.org/TR/2014/NOTE-rdf11-primer-20140624/">https:/​/​www.w3.org/TR/2014/NOTE-rdf11-primer-20140624/</a> (2014).</dd>
  <dt id="ref-13">[13]</dt>
  <dd resource="https://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" typeof="schema:CreativeWork">Carroll, J., Klyne, G.: Resource Description Framework (RDF): Concepts and Abstract Syntax. W3C, <a href="https://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">https:/​/​www.w3.org/TR/2004/REC-rdf-concepts-20040210/</a> (2004).</dd>
  <dt id="ref-14">[14]</dt>
  <dd resource="#heath2011linked" typeof="schema:Article">Heath, T., Bizer, C.: Linked data: Evolving the web into a global data space. Synthesis lectures on the semantic web: theory and technology. 1, 1–136 (2011).</dd>
  <dt id="ref-15">[15]</dt>
  <dd resource="https://www.w3.org/TR/2014/REC-trig-20140225/" typeof="schema:CreativeWork">Seaborne, A., Carothers, G.: RDF 1.1 TriG. W3C, <a href="https://www.w3.org/TR/2014/REC-trig-20140225/">https:/​/​www.w3.org/TR/2014/REC-trig-20140225/</a> (2014).</dd>
  <dt id="ref-16">[16]</dt>
  <dd resource="#microdata" typeof="schema:CreativeWork">’chaals’ (McCathie) Nevile, C., Brickley, D., Hickson, I.: HTML Microdata. W3C (2018).</dd>
  <dt id="ref-17">[17]</dt>
  <dd resource="#tennison2016csv" typeof="schema:Article">Tennison, J.: CSV on the Web: A Primer. W3C working group note (World Wide Web Consortium, Cambridge, 2014). (2016).</dd>
  <dt id="ref-18">[18]</dt>
  <dd resource="#protobuf" typeof="schema:CreativeWork">Language Guide. <a href="https://developers.google.com/protocol-buffers/docs/overview">https:/​/​developers.google.com/protocol-buffers/docs/overview</a></dd>
  <dt id="ref-19">[19]</dt>
  <dd resource="#flatbuf" typeof="schema:CreativeWork">FlatBuffers. <a href="https://google.github.io/flatbuffers/">https:/​/​google.github.io/flatbuffers/</a></dd>
  <dt id="ref-20">[20]</dt>
  <dd resource="#hdt" typeof="schema:CreativeWork">HDT Binary Format. <a href="https://www.rdfhdt.org/hdt-binary-format/">https:/​/​www.rdfhdt.org/hdt-binary-format/</a> (2015).</dd>
  <dt id="ref-21">[21]</dt>
  <dd resource="http://ceur-ws.org/Vol-1184/ldow2014_paper_01.pdf" typeof="schema:Article">Dimou, A., Vander Sande, M., Colpaert, P., Verborgh, R., Mannens, E., Van de Walle, R.: RML: A Generic Language for Integrated RDF Mappings of Heterogeneous Data. In: Bizer, C., Heath, T., Auer, S., and Berners-Lee, T. (eds.) Proceedings of the 7th Workshop on Linked Data on the Web (2014).</dd>
  <dt id="ref-22">[22]</dt>
  <dd resource="https://www.w3.org/TR/2013/REC-sparql11-overview-20130321/" typeof="schema:CreativeWork">SPARQL 1.1 Overview. W3C, <a href="https://www.w3.org/TR/2013/REC-sparql11-overview-20130321/">https:/​/​www.w3.org/TR/2013/REC-sparql11-overview-20130321/</a> (2013).</dd>
  <dt id="ref-23">[23]</dt>
  <dd resource="https://dx.doi.org/10.1016/j.websem.2018.08.002" typeof="schema:Article">Arndt, N., Naumann, P., Radtke, N., Martin, M., Marx, E.: Decentralized Collaborative Knowledge Management Using Git. Journal of Web Semantics. 54, (2018).</dd>
  <dt id="ref-24">[24]</dt>
  <dd resource="https://dx.doi.org/10.3233/SW-180309" typeof="schema:Article">Fernández, J., Umbrich, J., Polleres, A., Knuth, M.: Evaluating query and storage strategies for RDF archives. Semantic Web. 10, 1–45 (2018).</dd>
  <dt id="ref-25">[25]</dt>
  <dd resource="#rdfquerytypes" typeof="schema:Article">Fernández, J., Polleres, A., Umbrich, J.: Towards efficient archiving of dynamic linked open data. CEUR Workshop Proceedings. 1377, 34–49 (2015).</dd>
  <dt id="ref-26">[26]</dt>
  <dd resource="https://dx.doi.org/10.1145/3184558.3186960" typeof="schema:Article">Taelman, R., Vander Sande, M., Verborgh, R.: OSTRICH: Versioned Random-Access Triple Store. In: Companion Proceedings of the The Web Conference 2018. pp. 127–130. International World Wide Web Conferences Steering Committee, Republic and Canton of Geneva, CHE (2018).</dd>
  <dt id="ref-27">[27]</dt>
  <dd resource="https://dx.doi.org/10.1016/j.websem.2018.08.001" typeof="schema:Article">Taelman, R., Vander Sande, M., Herwegen, J., Mannens, E., Verborgh, R.: Triple storage for random-access versioned querying of RDF archives. Journal of Web Semantics. 54, (2018).</dd>
  <dt id="ref-28">[28]</dt>
  <dd resource="#delva2020geospatial" typeof="schema:Article">Delva, H., Rojas, J.A., Vandenberghe, P.-J., Colpaert, P., Verborgh, R.: Geospatial Partitioning of Open Transit Data. In: International Conference on Web Engineering. pp. 305–320. Springer (2020).</dd>
  <dt id="ref-29">[29]</dt>
  <dd resource="https://dx.doi.org/10.1088/1742-6596/853/1/012003" typeof="schema:Article">Atmoko, R., Riantini, R., Hasin, M.: IoT real time data acquisition using MQTT protocol. Journal of Physics: Conference Series. 853, 012003 (2017).</dd>
  <dt id="ref-30">[30]</dt>
  <dd resource="https://dx.doi.org/https://cloud.google.com/blog/products/iot-devices/http-vs-mqtt-a-tale-of-two-iot-protocols" typeof="schema:Article">Wang, C.: HTTP vs. MQTT: A tale of two IoT protocols. (2002).</dd>
  <dt id="ref-31">[31]</dt>
  <dd resource="#van2020comparing" typeof="schema:Article">Van de Vyvere, B., Colpaert, P., Verborgh, R.: Comparing a polling and push-based approach for live Open Data interfaces. In: International Conference on Web Engineering. pp. 87–101. Springer (2020).</dd>
  <dt id="ref-32">[32]</dt>
  <dd resource="#gregorio2005atom" typeof="schema:CreativeWork">Gregorio, J., de hOra, B.: The Atom Publishing Protocol. RFC Editor (2007).</dd>
  <dt id="ref-33">[33]</dt>
  <dd resource="http://www.intertwingly.net/wiki/pie/Rss20AndAtom10Compared" typeof="schema:Article">Ruby, S.: Rss 2.0 and atom 1.0 compared. 10, (2008).</dd>
  <dt id="ref-34">[34]</dt>
  <dd resource="https://www.w3.org/TR/2017/REC-ldn-20170502/" typeof="schema:CreativeWork">Guy, A., Capadisli, S.: Linked Data Notifications. W3C, <a href="https://www.w3.org/TR/2017/REC-ldn-20170502/">https:/​/​www.w3.org/TR/2017/REC-ldn-20170502/</a> (2017).</dd>
  <dt id="ref-35">[35]</dt>
  <dd resource="#capadisli2017linked" typeof="schema:Article">Capadisli, S., Guy, A., Lange, C., Auer, S., Sambra, A., Berners-Lee, T.: Linked data notifications: a resource-centric communication protocol. In: European Semantic Web Conference. pp. 537–553. Springer (2017).</dd>
  <dt id="ref-36">[36]</dt>
  <dd resource="https://www.w3.org/TR/2018/REC-websub-20180123/" typeof="schema:CreativeWork">Parecki, A., Genestoux, J.: WebSub. W3C, <a href="https://www.w3.org/TR/2018/REC-websub-20180123/">https:/​/​www.w3.org/TR/2018/REC-websub-20180123/</a> (2018).</dd>
  <dt id="ref-37">[37]</dt>
  <dd resource="https://dx.doi.org/10.1007/978-3-319-25010-6_24" typeof="schema:Article">Dividino, R., Gottron, T., Scherp, A.: Strategies for Efficiently Keeping Local Linked Open Data Caches Up-To-Date. In: Arenas, M and Corcho, O and Simperl, E and Strohmaier, M and DAquin, M and Srinivas, K and Groth, P and Dumontier, M and Heflin, J and Thirunarayan, K and Staab, S (ed.) SEMANTIC WEB - ISWC 2015, PT II. pp. 356–373. Elsevier; Fujitsu; Google; iMinds; Ontotext; Systap; Yahoo Labs; Franz Inc; IBM Res; Oracle; Metaphacts; Blazegraph (2015).</dd>
  <dt id="ref-38">[38]</dt>
  <dd resource="https://dx.doi.org/10.1145/3106426.3106463" typeof="schema:Article">Nishioka, C., Scherp, A.: Keeping linked open data caches up-to-date by predicting the life-time of RDF triples. Proceedings of the International Conference on Web Intelligence. (2017).</dd>
  <dt id="ref-39">[39]</dt>
  <dd resource="https://dx.doi.org/10.1109/ACCESS.2018.2871511" typeof="schema:Article">Akhtar, U., Razzaq, M., Rehman, U.U., Amin, M., Khan, W., Huh, E.-nam, Lee, S.: Change-Aware Scheduling for Effectively Updating Linked Open Data Caches. IEEE Access. PP, 1–1 (2018).</dd>
  <dt id="ref-40">[40]</dt>
  <dd resource="https://dx.doi.org/10.1145/3184558.3191650" typeof="schema:Article">Rojas Meléndez, J.A., Van de Vyvere, B., Gevaert, A., Taelman, R., Colpaert, P., Verborgh, R.: A Preliminary Open Data Publishing Strategy for Live Data in Flanders. In: Companion Proceedings of the The Web Conference 2018. pp. 1847–1853. International World Wide Web Conferences Steering Committee, Republic and Canton of Geneva, CHE (2018).</dd>
  <dt id="ref-41">[41]</dt>
  <dd resource="https://dx.doi.org/10.1007/s00607-020-00814-9" typeof="schema:Article">Akhtar, U., Sant’Anna, A., Jihn, C.-H., Razzaq, M.A., Bang, J., Lee, S.: A cache-based method to improve query performance of linked Open Data cloud. COMPUTING. 102, 1743–1763 (2020).</dd>
  <dt id="ref-42">[42]</dt>
  <dd resource="https://dx.doi.org/10.1109/WISA.2013.10" typeof="schema:Article">Yi, X., Zheng, F., Jia, W.: Two Layer Cache for RDF Database. In: 2013 10TH WEB INFORMATION SYSTEM AND APPLICATION CONFERENCE (WISA 2013). p. 11+. IEEE Comp Soc; Chinese Comp Federat; IEEE; Yangzhou Univ; Xian Jiaotong Univ; Liaoning Normal Univ; NE Univ; Nanjing Univ (2013).</dd>
  <dt id="ref-43">[43]</dt>
  <dd resource="https://dx.doi.org/10.1007/978-3-319-34129-3_28" typeof="schema:Article">Folz, P., Skaf-Molli, H., Molli, P.: CyCLaDEs: A Decentralized Cache for Triple Pattern Fragments. Presented at the May (2016).</dd>
  <dt id="ref-44">[44]</dt>
  <dd resource="https://dx.doi.org/10.1145/3286062.3286082" typeof="schema:Article">Berger, D.S.: Towards Lightweight and Robust Machine Learning for CDN Caching. In: Proceedings of the 17th ACM Workshop on Hot Topics in Networks. pp. 134–140. Association for Computing Machinery, New York, NY, USA (2018).</dd>
  <dt id="ref-45">[45]</dt>
  <dd resource="https://dx.doi.org/10.1109/ICPADS.2012.106" typeof="schema:Article">Li, Q., He, H., Fang, B.-X., Zhang, H.-L.: A Novel Cache Replacement Policy for ISP Merged CDN. In: Proceedings of the 2012 IEEE 18th International Conference on Parallel and Distributed Systems. pp. 708–709. IEEE Computer Society, USA (2012).</dd>
  <dt id="ref-46">[46]</dt>
  <dd resource="https://doi.org/10.5167/uzh-149682" typeof="schema:Article">Dell’Aglio, D., Phuoc, D.L., Le-Tuan, A., Ali, M.I., Calbimonte, J.-P.: On a Web of Data Streams. In: ISWC2017 workshop on Decentralizing the Semantic Web. s.n. (2017).</dd>
  <dt id="ref-47">[47]</dt>
  <dd resource="#mauri2016triplewave" typeof="schema:Article">Mauri, A., Calbimonte, J.-P., Dell’Aglio, D., Balduini, M., Brambilla, M., Della Valle, E., Aberer, K.: Triplewave: Spreading RDF streams on the web. In: International Semantic Web Conference. pp. 140–149. Springer (2016).</dd>
  <dt id="ref-48">[48]</dt>
  <dd resource="https://dx.doi.org/10.1145/1107499.1107504" typeof="schema:Article">Stonebraker, M., Çetintemel, U., Zdonik, S.: The 8 Requirements of Real-Time Stream Processing. SIGMOD Rec. 34, 42–47 (2005).</dd>
</dl>
</section>
</footer>


<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:exmp" role="doc-endnote">
      <p>https:/​/​data.gov.be/en/dataset/d4961387-23f4-44f8-b2e7-c7e9a260a83e Example dataset which counts the number of bikers on several locations in Brussels <a href="#fnref:exmp" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:covid" role="doc-endnote">
      <p>https:/​/​epistat.wiv-isp.be/covid/ Belgian COVID data. This data is updated regularly, but not in real-time. <a href="#fnref:covid" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:unicodespec" role="doc-endnote">
      <p>https:/​/​unicode.org/standard/standard.html <a href="#fnref:unicodespec" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:urispec" role="doc-endnote">
      <p>https:/​/​www.w3.org/Addressing/URL/uri-spec.html <a href="#fnref:urispec" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:rdf-example" role="doc-endnote">
      <p>https:/​/​www.w3.org/TR/turtle/ <a href="#fnref:rdf-example" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:csvw-w3-example" role="doc-endnote">
      <p>https:/​/​www.w3.org/TR/tabular-data-primer/ <a href="#fnref:csvw-w3-example" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:w3c" role="doc-endnote">
      <p>https:/​/​www.w3.org/blog/SW/2008/01/15/sparql_is_a_recommendation/ <a href="#fnref:w3c" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:sql" role="doc-endnote">
      <p>https:/​/​www.w3schools.com/sql/sql_quickref.asp <a href="#fnref:sql" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:sparql-w3-example" role="doc-endnote">
      <p>https:/​/​www.w3.org/2009/Talks/0615-qbe/ <a href="#fnref:sparql-w3-example" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:cve" role="doc-endnote">
      <p>https:/​/​www.cvedetails.com/google-search-results.php?q=MQTT <a href="#fnref:cve" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:rssspec" role="doc-endnote">
      <p>https:/​/​www.xml.com/pub/a/2002/12/18/dive-into-xml.html <a href="#fnref:rssspec" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:nginx" role="doc-endnote">
      <p>A high-performant web server and reverse proxy (http://nginx.org) <a href="#fnref:nginx" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

</body>
</html>
